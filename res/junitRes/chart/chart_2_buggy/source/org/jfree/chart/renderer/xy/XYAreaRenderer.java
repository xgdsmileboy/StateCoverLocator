package org.jfree.chart.renderer.xy;
import java.awt.BasicStroke;
import java.awt.GradientPaint;
import java.awt.Graphics2D;
import java.awt.Paint;
import java.awt.Polygon;
import java.awt.Shape;
import java.awt.Stroke;
import java.awt.geom.Area;
import java.awt.geom.GeneralPath;
import java.awt.geom.Line2D;
import java.awt.geom.Rectangle2D;
import java.io.IOException;
import java.io.ObjectInputStream;
import java.io.ObjectOutputStream;
import org.jfree.chart.LegendItem;
import org.jfree.chart.axis.ValueAxis;
import org.jfree.chart.entity.EntityCollection;
import org.jfree.chart.event.RendererChangeEvent;
import org.jfree.chart.labels.XYSeriesLabelGenerator;
import org.jfree.chart.labels.XYToolTipGenerator;
import org.jfree.chart.plot.PlotOrientation;
import org.jfree.chart.plot.PlotRenderingInfo;
import org.jfree.chart.plot.XYCrosshairState;
import org.jfree.chart.plot.XYPlot;
import org.jfree.chart.urls.XYURLGenerator;
import org.jfree.chart.util.GradientPaintTransformer;
import org.jfree.chart.util.HashUtilities;
import org.jfree.chart.util.PublicCloneable;
import org.jfree.chart.util.SerialUtilities;
import org.jfree.chart.util.ShapeUtilities;
import org.jfree.chart.util.StandardGradientPaintTransformer;
import org.jfree.data.xy.XYDataset;
/** 
 * Area item renderer for an                                                                                                                                                                     {@link XYPlot}.  This class can draw (a) shapes at each point, or (b) lines between points, or (c) both shapes and lines, or (d) filled areas, or (e) filled areas and shapes. The example shown here is generated by the <code>XYAreaRendererDemo1.java</code> program included in the JFreeChart demo collection: <br><br> <img src="../../../../../images/XYAreaRendererSample.png" alt="XYAreaRendererSample.png" />
 */
public class XYAreaRenderer extends AbstractXYItemRenderer implements XYItemRenderer, PublicCloneable {
  /** 
 * For serialization. 
 */
  private static final long serialVersionUID=-4481971353973876747L;
  /** 
 * A state object used by this renderer.
 */
static class XYAreaRendererState extends XYItemRendererState {
    /** 
 * Working storage for the area under one series. 
 */
    public Polygon area;
    /** 
 * Working line that can be recycled. 
 */
    public Line2D line;
    /** 
 * Creates a new state.
 * @param info  the plot rendering info.
 */
    public XYAreaRendererState(    PlotRenderingInfo info){
      super(info);
      this.area=new Polygon();
      this.line=new Line2D.Double();
    }
  }
  /** 
 * Useful constant for specifying the type of rendering (shapes only). 
 */
  public static final int SHAPES=1;
  /** 
 * Useful constant for specifying the type of rendering (lines only). 
 */
  public static final int LINES=2;
  /** 
 * Useful constant for specifying the type of rendering (shapes and lines).
 */
  public static final int SHAPES_AND_LINES=3;
  /** 
 * Useful constant for specifying the type of rendering (area only). 
 */
  public static final int AREA=4;
  /** 
 * Useful constant for specifying the type of rendering (area and shapes).
 */
  public static final int AREA_AND_SHAPES=5;
  /** 
 * A flag indicating whether or not shapes are drawn at each XY point. 
 */
  private boolean plotShapes;
  /** 
 * A flag indicating whether or not lines are drawn between XY points. 
 */
  private boolean plotLines;
  /** 
 * A flag indicating whether or not Area are drawn at each XY point. 
 */
  private boolean plotArea;
  /** 
 * A flag that controls whether or not the outline is shown. 
 */
  private boolean showOutline;
  /** 
 * The shape used to represent an area in each legend item (this should never be <code>null</code>).
 */
  private transient Shape legendArea;
  /** 
 * A flag that can be set to specify that the fill paint should be used to fill the area under the renderer.
 * @since 1.0.14
 */
  private boolean useFillPaint;
  /** 
 * A transformer that is applied to the paint used to fill under the area *if* it is an instance of GradientPaint.
 * @since 1.0.14
 */
  private GradientPaintTransformer gradientTransformer;
  /** 
 * Constructs a new renderer.
 */
  public XYAreaRenderer(){
    this(AREA);
  }
  /** 
 * Constructs a new renderer.
 * @param type  the type of the renderer.
 */
  public XYAreaRenderer(  int type){
    this(type,null,null);
  }
  /** 
 * Constructs a new renderer.  To specify the type of renderer, use one of the constants: <code>SHAPES</code>, <code>LINES</code>, <code>SHAPES_AND_LINES</code>, <code>AREA</code> or <code>AREA_AND_SHAPES</code>.
 * @param type  the type of renderer.
 * @param toolTipGenerator  the tool tip generator to use(<code>null</code> permitted).
 * @param urlGenerator  the URL generator (<code>null</code> permitted).
 */
  public XYAreaRenderer(  int type,  XYToolTipGenerator toolTipGenerator,  XYURLGenerator urlGenerator){
    super();
    setBaseToolTipGenerator(toolTipGenerator);
    setBaseURLGenerator(urlGenerator);
    if (type == SHAPES) {
      this.plotShapes=true;
    }
    if (type == LINES) {
      this.plotLines=true;
    }
    if (type == SHAPES_AND_LINES) {
      this.plotShapes=true;
      this.plotLines=true;
    }
    if (type == AREA) {
      this.plotArea=true;
    }
    if (type == AREA_AND_SHAPES) {
      this.plotArea=true;
      this.plotShapes=true;
    }
    this.showOutline=false;
    GeneralPath area=new GeneralPath();
    area.moveTo(0.0f,-4.0f);
    area.lineTo(3.0f,-2.0f);
    area.lineTo(4.0f,4.0f);
    area.lineTo(-4.0f,4.0f);
    area.lineTo(-3.0f,-2.0f);
    area.closePath();
    this.legendArea=area;
    this.useFillPaint=false;
    this.gradientTransformer=new StandardGradientPaintTransformer();
  }
  /** 
 * Returns true if shapes are being plotted by the renderer.
 * @return <code>true</code> if shapes are being plotted by the renderer.
 */
  public boolean getPlotShapes(){
    return this.plotShapes;
  }
  /** 
 * Returns true if lines are being plotted by the renderer.
 * @return <code>true</code> if lines are being plotted by the renderer.
 */
  public boolean getPlotLines(){
    return this.plotLines;
  }
  /** 
 * Returns true if Area is being plotted by the renderer.
 * @return <code>true</code> if Area is being plotted by the renderer.
 */
  public boolean getPlotArea(){
    return this.plotArea;
  }
  /** 
 * Returns a flag that controls whether or not outlines of the areas are drawn.
 * @return The flag.
 * @see #setOutline(boolean)
 */
  public boolean isOutline(){
    return this.showOutline;
  }
  /** 
 * Sets a flag that controls whether or not outlines of the areas are drawn and sends a                                                                                                                                                                     {@link RendererChangeEvent} to all registered listeners.
 * @param show  the flag.
 * @see #isOutline()
 */
  public void setOutline(  boolean show){
    this.showOutline=show;
    fireChangeEvent();
  }
  /** 
 * Returns the shape used to represent an area in the legend.
 * @return The legend area (never <code>null</code>).
 */
  public Shape getLegendArea(){
    return this.legendArea;
  }
  /** 
 * Sets the shape used as an area in each legend item and sends a                                                                                                                                                                    {@link RendererChangeEvent} to all registered listeners.
 * @param area  the area (<code>null</code> not permitted).
 */
  public void setLegendArea(  Shape area){
    if (area == null) {
      throw new IllegalArgumentException("Null 'area' argument.");
    }
    this.legendArea=area;
    fireChangeEvent();
  }
  /** 
 * Returns the flag that controls whether the series fill paint is used to fill the area under the line.
 * @return A boolean.
 * @since 1.0.14
 */
  public boolean getUseFillPaint(){
    return this.useFillPaint;
  }
  /** 
 * Sets the flag that controls whether or not the series fill paint is used to fill the area under the line and sends a                                                                                                                                                                    {@link RendererChangeEvent} to all listeners.
 * @param use  the new flag value.
 * @since 1.0.14
 */
  public void setUseFillPaint(  boolean use){
    this.useFillPaint=use;
    fireChangeEvent();
  }
  /** 
 * Returns the gradient paint transformer.
 * @return The gradient paint transformer (never <code>null</code>).
 * @since 1.0.14
 */
  public GradientPaintTransformer getGradientTransformer(){
    return this.gradientTransformer;
  }
  /** 
 * Sets the gradient paint transformer and sends a                                                                                                                                                                    {@link RendererChangeEvent} to all registered listeners.
 * @param transformer  the transformer (<code>null</code> not permitted).
 * @since 1.0.14
 */
  public void setGradientTransformer(  GradientPaintTransformer transformer){
    if (transformer == null) {
      throw new IllegalArgumentException("Null 'transformer' argument.");
    }
    this.gradientTransformer=transformer;
    fireChangeEvent();
  }
  /** 
 * Initialises the renderer and returns a state object that should be passed to all subsequent calls to the drawItem() method.
 * @param g2  the graphics device.
 * @param dataArea  the area inside the axes.
 * @param plot  the plot.
 * @param data  the data.
 * @param info  an optional info collection object to return data back tothe caller.
 * @return A state object for use by the renderer.
 */
  public XYItemRendererState initialise(  Graphics2D g2,  Rectangle2D dataArea,  XYPlot plot,  XYDataset data,  PlotRenderingInfo info){
    XYAreaRendererState state=new XYAreaRendererState(info);
    state.setProcessVisibleItemsOnly(false);
    return state;
  }
  /** 
 * Returns a default legend item for the specified series.  Subclasses should override this method to generate customised items.
 * @param datasetIndex  the dataset index (zero-based).
 * @param series  the series index (zero-based).
 * @return A legend item for the series.
 */
  public LegendItem getLegendItem(  int datasetIndex,  int series){
    LegendItem result=null;
    XYPlot xyplot=getPlot();
    if (xyplot != null) {
      XYDataset dataset=xyplot.getDataset(datasetIndex);
      if (dataset != null) {
        XYSeriesLabelGenerator lg=getLegendItemLabelGenerator();
        String label=lg.generateLabel(dataset,series);
        String description=label;
        String toolTipText=null;
        if (getLegendItemToolTipGenerator() != null) {
          toolTipText=getLegendItemToolTipGenerator().generateLabel(dataset,series);
        }
        String urlText=null;
        if (getLegendItemURLGenerator() != null) {
          urlText=getLegendItemURLGenerator().generateLabel(dataset,series);
        }
        Paint paint=lookupSeriesPaint(series);
        result=new LegendItem(label,description,toolTipText,urlText,this.legendArea,paint);
        result.setLabelFont(lookupLegendTextFont(series));
        Paint labelPaint=lookupLegendTextPaint(series);
        if (labelPaint != null) {
          result.setLabelPaint(labelPaint);
        }
        result.setDataset(dataset);
        result.setDatasetIndex(datasetIndex);
        result.setSeriesKey(dataset.getSeriesKey(series));
        result.setSeriesIndex(series);
      }
    }
    return result;
  }
  /** 
 * Draws the visual representation of a single data item.
 * @param g2  the graphics device.
 * @param state  the renderer state.
 * @param dataArea  the area within which the data is being drawn.
 * @param plot  the plot (can be used to obtain standard color informationetc).
 * @param domainAxis  the domain axis.
 * @param rangeAxis  the range axis.
 * @param dataset  the dataset.
 * @param series  the series index (zero-based).
 * @param item  the item index (zero-based).
 * @param pass  the pass index.
 */
  public void drawItem(  Graphics2D g2,  XYItemRendererState state,  Rectangle2D dataArea,  XYPlot plot,  ValueAxis domainAxis,  ValueAxis rangeAxis,  XYDataset dataset,  int series,  int item,  boolean selected,  int pass){
    if (!getItemVisible(series,item)) {
      return;
    }
    XYAreaRendererState areaState=(XYAreaRendererState)state;
    double x1=dataset.getXValue(series,item);
    double y1=dataset.getYValue(series,item);
    if (Double.isNaN(y1)) {
      y1=0.0;
    }
    double transX1=domainAxis.valueToJava2D(x1,dataArea,plot.getDomainAxisEdge());
    double transY1=rangeAxis.valueToJava2D(y1,dataArea,plot.getRangeAxisEdge());
    int itemCount=dataset.getItemCount(series);
    double x0=dataset.getXValue(series,Math.max(item - 1,0));
    double y0=dataset.getYValue(series,Math.max(item - 1,0));
    if (Double.isNaN(y0)) {
      y0=0.0;
    }
    double transX0=domainAxis.valueToJava2D(x0,dataArea,plot.getDomainAxisEdge());
    double transY0=rangeAxis.valueToJava2D(y0,dataArea,plot.getRangeAxisEdge());
    double x2=dataset.getXValue(series,Math.min(item + 1,itemCount - 1));
    double y2=dataset.getYValue(series,Math.min(item + 1,itemCount - 1));
    if (Double.isNaN(y2)) {
      y2=0.0;
    }
    double transX2=domainAxis.valueToJava2D(x2,dataArea,plot.getDomainAxisEdge());
    double transY2=rangeAxis.valueToJava2D(y2,dataArea,plot.getRangeAxisEdge());
    double transZero=rangeAxis.valueToJava2D(0.0,dataArea,plot.getRangeAxisEdge());
    Polygon hotspot=null;
    if (plot.getOrientation() == PlotOrientation.HORIZONTAL) {
      hotspot=new Polygon();
      hotspot.addPoint((int)transZero,(int)((transX0 + transX1) / 2.0));
      hotspot.addPoint((int)((transY0 + transY1) / 2.0),(int)((transX0 + transX1) / 2.0));
      hotspot.addPoint((int)transY1,(int)transX1);
      hotspot.addPoint((int)((transY1 + transY2) / 2.0),(int)((transX1 + transX2) / 2.0));
      hotspot.addPoint((int)transZero,(int)((transX1 + transX2) / 2.0));
    }
 else {
      hotspot=new Polygon();
      hotspot.addPoint((int)((transX0 + transX1) / 2.0),(int)transZero);
      hotspot.addPoint((int)((transX0 + transX1) / 2.0),(int)((transY0 + transY1) / 2.0));
      hotspot.addPoint((int)transX1,(int)transY1);
      hotspot.addPoint((int)((transX1 + transX2) / 2.0),(int)((transY1 + transY2) / 2.0));
      hotspot.addPoint((int)((transX1 + transX2) / 2.0),(int)transZero);
    }
    if (item == 0) {
      areaState.area=new Polygon();
      double zero=rangeAxis.valueToJava2D(0.0,dataArea,plot.getRangeAxisEdge());
      if (plot.getOrientation() == PlotOrientation.VERTICAL) {
        areaState.area.addPoint((int)transX1,(int)zero);
      }
 else {
        if (plot.getOrientation() == PlotOrientation.HORIZONTAL) {
          areaState.area.addPoint((int)zero,(int)transX1);
        }
      }
    }
    if (plot.getOrientation() == PlotOrientation.VERTICAL) {
      areaState.area.addPoint((int)transX1,(int)transY1);
    }
 else {
      if (plot.getOrientation() == PlotOrientation.HORIZONTAL) {
        areaState.area.addPoint((int)transY1,(int)transX1);
      }
    }
    PlotOrientation orientation=plot.getOrientation();
    Paint paint=getItemPaint(series,item,selected);
    Stroke stroke=getItemStroke(series,item,selected);
    g2.setPaint(paint);
    g2.setStroke(stroke);
    Shape shape=null;
    if (getPlotShapes()) {
      shape=getItemShape(series,item,selected);
      if (orientation == PlotOrientation.VERTICAL) {
        shape=ShapeUtilities.createTranslatedShape(shape,transX1,transY1);
      }
 else {
        if (orientation == PlotOrientation.HORIZONTAL) {
          shape=ShapeUtilities.createTranslatedShape(shape,transY1,transX1);
        }
      }
      g2.draw(shape);
    }
    if (getPlotLines()) {
      if (item > 0) {
        if (plot.getOrientation() == PlotOrientation.VERTICAL) {
          areaState.line.setLine(transX0,transY0,transX1,transY1);
        }
 else {
          if (plot.getOrientation() == PlotOrientation.HORIZONTAL) {
            areaState.line.setLine(transY0,transX0,transY1,transX1);
          }
        }
        g2.draw(areaState.line);
      }
    }
    if (getPlotArea() && item > 0 && item == (itemCount - 1)) {
      if (orientation == PlotOrientation.VERTICAL) {
        areaState.area.addPoint((int)transX1,(int)transZero);
      }
 else {
        if (orientation == PlotOrientation.HORIZONTAL) {
          areaState.area.addPoint((int)transZero,(int)transX1);
        }
      }
      if (this.useFillPaint) {
        paint=lookupSeriesFillPaint(series);
      }
      if (paint instanceof GradientPaint) {
        GradientPaint gp=(GradientPaint)paint;
        GradientPaint adjGP=this.gradientTransformer.transform(gp,dataArea);
        g2.setPaint(adjGP);
      }
      g2.fill(areaState.area);
      if (isOutline()) {
        Shape area=areaState.area;
        Stroke outlineStroke=lookupSeriesOutlineStroke(series);
        if (outlineStroke instanceof BasicStroke) {
          BasicStroke bs=(BasicStroke)outlineStroke;
          if (bs.getDashArray() != null) {
            Area poly=new Area(areaState.area);
            Area clip=new Area(new Rectangle2D.Double(dataArea.getX() - 5.0,dataArea.getY() - 5.0,dataArea.getWidth() + 10.0,dataArea.getHeight() + 10.0));
            poly.intersect(clip);
            area=poly;
          }
        }
        g2.setStroke(outlineStroke);
        g2.setPaint(lookupSeriesOutlinePaint(series));
        g2.draw(area);
      }
    }
    int domainAxisIndex=plot.getDomainAxisIndex(domainAxis);
    int rangeAxisIndex=plot.getRangeAxisIndex(rangeAxis);
    XYCrosshairState crosshairState=state.getCrosshairState();
    updateCrosshairValues(crosshairState,x1,y1,domainAxisIndex,rangeAxisIndex,transX1,transY1,orientation);
    EntityCollection entities=state.getEntityCollection();
    if (entities != null && hotspot != null) {
      addEntity(entities,hotspot,dataset,series,item,selected,0.0,0.0);
    }
  }
  /** 
 * Returns a clone of the renderer.
 * @return A clone.
 * @throws CloneNotSupportedException  if the renderer cannot be cloned.
 */
  public Object clone() throws CloneNotSupportedException {
    XYAreaRenderer clone=(XYAreaRenderer)super.clone();
    clone.legendArea=ShapeUtilities.clone(this.legendArea);
    return clone;
  }
  /** 
 * Tests this renderer for equality with an arbitrary object.
 * @param obj  the object (<code>null</code> permitted).
 * @return A boolean.
 */
  public boolean equals(  Object obj){
    if (obj == this) {
      return true;
    }
    if (!(obj instanceof XYAreaRenderer)) {
      return false;
    }
    XYAreaRenderer that=(XYAreaRenderer)obj;
    if (this.plotArea != that.plotArea) {
      return false;
    }
    if (this.plotLines != that.plotLines) {
      return false;
    }
    if (this.plotShapes != that.plotShapes) {
      return false;
    }
    if (this.showOutline != that.showOutline) {
      return false;
    }
    if (this.useFillPaint != that.useFillPaint) {
      return false;
    }
    if (!this.gradientTransformer.equals(that.gradientTransformer)) {
      return false;
    }
    if (!ShapeUtilities.equal(this.legendArea,that.legendArea)) {
      return false;
    }
    return true;
  }
  /** 
 * Returns a hash code for this instance.
 * @return A hash code.
 */
  public int hashCode(){
    int result=super.hashCode();
    result=HashUtilities.hashCode(result,this.plotArea);
    result=HashUtilities.hashCode(result,this.plotLines);
    result=HashUtilities.hashCode(result,this.plotShapes);
    result=HashUtilities.hashCode(result,this.useFillPaint);
    return result;
  }
  /** 
 * Provides serialization support.
 * @param stream  the input stream.
 * @throws IOException  if there is an I/O error.
 * @throws ClassNotFoundException  if there is a classpath problem.
 */
  private void readObject(  ObjectInputStream stream) throws IOException, ClassNotFoundException {
    stream.defaultReadObject();
    this.legendArea=SerialUtilities.readShape(stream);
  }
  /** 
 * Provides serialization support.
 * @param stream  the output stream.
 * @throws IOException  if there is an I/O error.
 */
  private void writeObject(  ObjectOutputStream stream) throws IOException {
    stream.defaultWriteObject();
    SerialUtilities.writeShape(this.legendArea,stream);
  }
}
